{"ast":null,"code":"import { replaceInvalidDateByNull } from './date-utils';\nimport { addPositionPropertiesToSections, createDateStrForInputFromSections, splitFormatIntoSections, getSectionOrder } from '../hooks/useField/useField.utils';\nexport const singleItemValueManager = {\n  emptyValue: null,\n  getTodayValue: utils => utils.date(),\n  cleanValue: replaceInvalidDateByNull,\n  areValuesEqual: (utils, a, b) => utils.isEqual(a, b),\n  isSameError: (a, b) => a === b,\n  defaultErrorState: null\n};\nexport const singleItemFieldValueManager = {\n  updateReferenceValue: (utils, value, prevReferenceValue) => value == null || !utils.isValid(value) ? prevReferenceValue : value,\n  getSectionsFromValue: (utils, localeText, prevSections, date, format) => addPositionPropertiesToSections(splitFormatIntoSections(utils, localeText, format, date)),\n  getValueStrFromSections: sections => createDateStrForInputFromSections(sections),\n  getActiveDateSections: sections => sections,\n  getActiveDateManager: (utils, state) => ({\n    activeDate: state.value,\n    referenceActiveDate: state.referenceValue,\n    getNewValueFromNewActiveDate: newActiveDate => {\n      return {\n        value: newActiveDate,\n        referenceValue: newActiveDate == null || !utils.isValid(newActiveDate) ? state.referenceValue : newActiveDate\n      };\n    }\n  }),\n  parseValueStr: (valueStr, referenceValue, parseDate) => parseDate(valueStr.trim(), referenceValue),\n  hasError: error => error != null,\n  getSectionOrder: (utils, localeText, format, isRTL) => getSectionOrder(splitFormatIntoSections(utils, localeText, format, null), isRTL)\n};","map":{"version":3,"names":["replaceInvalidDateByNull","addPositionPropertiesToSections","createDateStrForInputFromSections","splitFormatIntoSections","getSectionOrder","singleItemValueManager","emptyValue","getTodayValue","utils","date","cleanValue","areValuesEqual","a","b","isEqual","isSameError","defaultErrorState","singleItemFieldValueManager","updateReferenceValue","value","prevReferenceValue","isValid","getSectionsFromValue","localeText","prevSections","format","getValueStrFromSections","sections","getActiveDateSections","getActiveDateManager","state","activeDate","referenceActiveDate","referenceValue","getNewValueFromNewActiveDate","newActiveDate","parseValueStr","valueStr","parseDate","trim","hasError","error","isRTL"],"sources":["/Users/alissonrubas/Desktop/workout_site/cliente/node_modules/@mui/x-date-pickers/internals/utils/valueManagers.js"],"sourcesContent":["import { replaceInvalidDateByNull } from './date-utils';\nimport { addPositionPropertiesToSections, createDateStrForInputFromSections, splitFormatIntoSections, getSectionOrder } from '../hooks/useField/useField.utils';\nexport const singleItemValueManager = {\n  emptyValue: null,\n  getTodayValue: utils => utils.date(),\n  cleanValue: replaceInvalidDateByNull,\n  areValuesEqual: (utils, a, b) => utils.isEqual(a, b),\n  isSameError: (a, b) => a === b,\n  defaultErrorState: null\n};\nexport const singleItemFieldValueManager = {\n  updateReferenceValue: (utils, value, prevReferenceValue) => value == null || !utils.isValid(value) ? prevReferenceValue : value,\n  getSectionsFromValue: (utils, localeText, prevSections, date, format) => addPositionPropertiesToSections(splitFormatIntoSections(utils, localeText, format, date)),\n  getValueStrFromSections: sections => createDateStrForInputFromSections(sections),\n  getActiveDateSections: sections => sections,\n  getActiveDateManager: (utils, state) => ({\n    activeDate: state.value,\n    referenceActiveDate: state.referenceValue,\n    getNewValueFromNewActiveDate: newActiveDate => {\n      return {\n        value: newActiveDate,\n        referenceValue: newActiveDate == null || !utils.isValid(newActiveDate) ? state.referenceValue : newActiveDate\n      };\n    }\n  }),\n  parseValueStr: (valueStr, referenceValue, parseDate) => parseDate(valueStr.trim(), referenceValue),\n  hasError: error => error != null,\n  getSectionOrder: (utils, localeText, format, isRTL) => getSectionOrder(splitFormatIntoSections(utils, localeText, format, null), isRTL)\n};"],"mappings":"AAAA,SAASA,wBAAwB,QAAQ,cAAc;AACvD,SAASC,+BAA+B,EAAEC,iCAAiC,EAAEC,uBAAuB,EAAEC,eAAe,QAAQ,kCAAkC;AAC/J,OAAO,MAAMC,sBAAsB,GAAG;EACpCC,UAAU,EAAE,IAAI;EAChBC,aAAa,EAAEC,KAAK,IAAIA,KAAK,CAACC,IAAI,EAAE;EACpCC,UAAU,EAAEV,wBAAwB;EACpCW,cAAc,EAAEA,CAACH,KAAK,EAAEI,CAAC,EAAEC,CAAC,KAAKL,KAAK,CAACM,OAAO,CAACF,CAAC,EAAEC,CAAC,CAAC;EACpDE,WAAW,EAAEA,CAACH,CAAC,EAAEC,CAAC,KAAKD,CAAC,KAAKC,CAAC;EAC9BG,iBAAiB,EAAE;AACrB,CAAC;AACD,OAAO,MAAMC,2BAA2B,GAAG;EACzCC,oBAAoB,EAAEA,CAACV,KAAK,EAAEW,KAAK,EAAEC,kBAAkB,KAAKD,KAAK,IAAI,IAAI,IAAI,CAACX,KAAK,CAACa,OAAO,CAACF,KAAK,CAAC,GAAGC,kBAAkB,GAAGD,KAAK;EAC/HG,oBAAoB,EAAEA,CAACd,KAAK,EAAEe,UAAU,EAAEC,YAAY,EAAEf,IAAI,EAAEgB,MAAM,KAAKxB,+BAA+B,CAACE,uBAAuB,CAACK,KAAK,EAAEe,UAAU,EAAEE,MAAM,EAAEhB,IAAI,CAAC,CAAC;EAClKiB,uBAAuB,EAAEC,QAAQ,IAAIzB,iCAAiC,CAACyB,QAAQ,CAAC;EAChFC,qBAAqB,EAAED,QAAQ,IAAIA,QAAQ;EAC3CE,oBAAoB,EAAEA,CAACrB,KAAK,EAAEsB,KAAK,MAAM;IACvCC,UAAU,EAAED,KAAK,CAACX,KAAK;IACvBa,mBAAmB,EAAEF,KAAK,CAACG,cAAc;IACzCC,4BAA4B,EAAEC,aAAa,IAAI;MAC7C,OAAO;QACLhB,KAAK,EAAEgB,aAAa;QACpBF,cAAc,EAAEE,aAAa,IAAI,IAAI,IAAI,CAAC3B,KAAK,CAACa,OAAO,CAACc,aAAa,CAAC,GAAGL,KAAK,CAACG,cAAc,GAAGE;MAClG,CAAC;IACH;EACF,CAAC,CAAC;EACFC,aAAa,EAAEA,CAACC,QAAQ,EAAEJ,cAAc,EAAEK,SAAS,KAAKA,SAAS,CAACD,QAAQ,CAACE,IAAI,EAAE,EAAEN,cAAc,CAAC;EAClGO,QAAQ,EAAEC,KAAK,IAAIA,KAAK,IAAI,IAAI;EAChCrC,eAAe,EAAEA,CAACI,KAAK,EAAEe,UAAU,EAAEE,MAAM,EAAEiB,KAAK,KAAKtC,eAAe,CAACD,uBAAuB,CAACK,KAAK,EAAEe,UAAU,EAAEE,MAAM,EAAE,IAAI,CAAC,EAAEiB,KAAK;AACxI,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}