{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nconst _excluded = [\"onClick\", \"onKeyDown\", \"onFocus\", \"onBlur\", \"onMouseUp\", \"onPaste\", \"error\"];\nimport * as React from 'react';\nimport useEnhancedEffect from '@mui/utils/useEnhancedEffect';\nimport useEventCallback from '@mui/utils/useEventCallback';\nimport useForkRef from '@mui/utils/useForkRef';\nimport { useValidation } from '../validation/useValidation';\nimport { useUtils } from '../useUtils';\nimport { adjustSectionValue, isAndroid, cleanString } from './useField.utils';\nimport { useFieldState } from './useFieldState';\nimport { useFieldCharacterEditing } from './useFieldCharacterEditing';\nexport const useField = params => {\n  const utils = useUtils();\n  if (!utils.formatTokenMap) {\n    throw new Error('This adapter is not compatible with the field components');\n  }\n  const {\n    state,\n    selectedSectionIndexes,\n    setSelectedSections,\n    clearValue,\n    clearActiveSection,\n    updateSectionValue,\n    updateValueFromValueStr,\n    setTempAndroidValueStr,\n    sectionOrder,\n    sectionsValueBoundaries\n  } = useFieldState(params);\n  const {\n    applyCharacterEditing,\n    resetCharacterQuery\n  } = useFieldCharacterEditing({\n    sections: state.sections,\n    updateSectionValue,\n    sectionsValueBoundaries,\n    setTempAndroidValueStr\n  });\n  const {\n      inputRef: inputRefProp,\n      internalProps,\n      internalProps: {\n        readOnly = false\n      },\n      forwardedProps: {\n        onClick,\n        onKeyDown,\n        onFocus,\n        onBlur,\n        onMouseUp,\n        onPaste,\n        error\n      },\n      fieldValueManager,\n      valueManager,\n      validator\n    } = params,\n    otherForwardedProps = _objectWithoutPropertiesLoose(params.forwardedProps, _excluded);\n  const inputRef = React.useRef(null);\n  const handleRef = useForkRef(inputRefProp, inputRef);\n  const focusTimeoutRef = React.useRef(undefined);\n  const syncSelectionFromDOM = () => {\n    var _selectionStart;\n    const browserStartIndex = (_selectionStart = inputRef.current.selectionStart) != null ? _selectionStart : 0;\n    const nextSectionIndex = browserStartIndex <= state.sections[0].startInInput ? 1 // Special case if browser index is in invisible characters at the beginning.\n    : state.sections.findIndex(section => section.startInInput - section.startSeparator.length > browserStartIndex);\n    const sectionIndex = nextSectionIndex === -1 ? state.sections.length - 1 : nextSectionIndex - 1;\n    setSelectedSections(sectionIndex);\n  };\n  const handleInputClick = useEventCallback(function () {\n    onClick == null ? void 0 : onClick(...arguments);\n    syncSelectionFromDOM();\n  });\n  const handleInputMouseUp = useEventCallback(event => {\n    onMouseUp == null ? void 0 : onMouseUp(event);\n\n    // Without this, the browser will remove the selected when clicking inside an already-selected section.\n    event.preventDefault();\n  });\n  const handleInputFocus = useEventCallback(function () {\n    onFocus == null ? void 0 : onFocus(...arguments);\n    // The ref is guaranteed to be resolved at this point.\n    const input = inputRef.current;\n    clearTimeout(focusTimeoutRef.current);\n    focusTimeoutRef.current = setTimeout(() => {\n      // The ref changed, the component got remounted, the focus event is no longer relevant.\n      if (!input || input !== inputRef.current) {\n        return;\n      }\n      if (selectedSectionIndexes != null) {\n        return;\n      }\n      if (\n      // avoid selecting all sections when focusing empty field without value\n      input.value.length && Number(input.selectionEnd) - Number(input.selectionStart) === input.value.length) {\n        setSelectedSections('all');\n      } else {\n        syncSelectionFromDOM();\n      }\n    });\n  });\n  const handleInputBlur = useEventCallback(function () {\n    onBlur == null ? void 0 : onBlur(...arguments);\n    setSelectedSections(null);\n  });\n  const handleInputPaste = useEventCallback(event => {\n    onPaste == null ? void 0 : onPaste(event);\n    if (readOnly) {\n      event.preventDefault();\n      return;\n    }\n    const pastedValue = event.clipboardData.getData('text');\n    if (selectedSectionIndexes && selectedSectionIndexes.startIndex === selectedSectionIndexes.endIndex) {\n      const activeSection = state.sections[selectedSectionIndexes.startIndex];\n      const lettersOnly = /^[a-zA-Z]+$/.test(pastedValue);\n      const digitsOnly = /^[0-9]+$/.test(pastedValue);\n      const isValidPastedValue = activeSection.contentType === 'letter' && lettersOnly || activeSection.contentType === 'digit' && digitsOnly;\n      if (isValidPastedValue) {\n        // Early return to let the paste update section, value\n        return;\n      }\n      if (lettersOnly || digitsOnly) {\n        // The pasted value correspond to a single section but not the expected type\n        // skip the modification\n        event.preventDefault();\n        return;\n      }\n    }\n    event.preventDefault();\n    updateValueFromValueStr(pastedValue);\n  });\n  const handleInputChange = useEventCallback(event => {\n    if (readOnly) {\n      return;\n    }\n    const valueStr = event.target.value;\n    const cleanValueStr = cleanString(valueStr);\n\n    // If no section is selected, we just try to parse the new value\n    // This line is mostly triggered by imperative code / application tests.\n    if (selectedSectionIndexes == null) {\n      updateValueFromValueStr(cleanValueStr);\n      return;\n    }\n    const prevValueStr = cleanString(fieldValueManager.getValueStrFromSections(state.sections));\n    let startOfDiffIndex = -1;\n    let endOfDiffIndex = -1;\n    for (let i = 0; i < prevValueStr.length; i += 1) {\n      if (startOfDiffIndex === -1 && prevValueStr[i] !== cleanValueStr[i]) {\n        startOfDiffIndex = i;\n      }\n      if (endOfDiffIndex === -1 && prevValueStr[prevValueStr.length - i - 1] !== cleanValueStr[cleanValueStr.length - i - 1]) {\n        endOfDiffIndex = i;\n      }\n    }\n    const activeSection = state.sections[selectedSectionIndexes.startIndex];\n    const hasDiffOutsideOfActiveSection = startOfDiffIndex < activeSection.start || prevValueStr.length - endOfDiffIndex - 1 > activeSection.end;\n    if (hasDiffOutsideOfActiveSection) {\n      // TODO: Support if the new date is valid\n      return;\n    }\n\n    // The active section being selected, the browser has replaced its value with the key pressed by the user.\n    const activeSectionEndRelativeToNewValue = cleanValueStr.length - prevValueStr.length + activeSection.end - cleanString(activeSection.endSeparator || '').length;\n    const keyPressed = cleanValueStr.slice(activeSection.start, activeSectionEndRelativeToNewValue);\n    if (isAndroid() && keyPressed.length === 0) {\n      setTempAndroidValueStr(valueStr);\n      return;\n    }\n    applyCharacterEditing({\n      keyPressed,\n      sectionIndex: selectedSectionIndexes.startIndex\n    });\n  });\n  const handleInputKeyDown = useEventCallback(event => {\n    onKeyDown == null ? void 0 : onKeyDown(event);\n\n    // eslint-disable-next-line default-case\n    switch (true) {\n      // Select all\n      case event.key === 'a' && (event.ctrlKey || event.metaKey):\n        {\n          // prevent default to make sure that the next line \"select all\" while updating\n          // the internal state at the same time.\n          event.preventDefault();\n          setSelectedSections('all');\n          break;\n        }\n\n      // Move selection to next section\n      case event.key === 'ArrowRight':\n        {\n          event.preventDefault();\n          if (selectedSectionIndexes == null) {\n            setSelectedSections(sectionOrder.startIndex);\n          } else if (selectedSectionIndexes.startIndex !== selectedSectionIndexes.endIndex) {\n            setSelectedSections(selectedSectionIndexes.endIndex);\n          } else {\n            const nextSectionIndex = sectionOrder.neighbors[selectedSectionIndexes.startIndex].rightIndex;\n            if (nextSectionIndex !== null) {\n              setSelectedSections(nextSectionIndex);\n            }\n          }\n          break;\n        }\n\n      // Move selection to previous section\n      case event.key === 'ArrowLeft':\n        {\n          event.preventDefault();\n          if (selectedSectionIndexes == null) {\n            setSelectedSections(sectionOrder.endIndex);\n          } else if (selectedSectionIndexes.startIndex !== selectedSectionIndexes.endIndex) {\n            setSelectedSections(selectedSectionIndexes.startIndex);\n          } else {\n            const nextSectionIndex = sectionOrder.neighbors[selectedSectionIndexes.startIndex].leftIndex;\n            if (nextSectionIndex !== null) {\n              setSelectedSections(nextSectionIndex);\n            }\n          }\n          break;\n        }\n\n      // Reset the value of the selected section\n      case ['Backspace', 'Delete'].includes(event.key):\n        {\n          event.preventDefault();\n          if (readOnly) {\n            break;\n          }\n          if (selectedSectionIndexes == null || selectedSectionIndexes.startIndex === 0 && selectedSectionIndexes.endIndex === state.sections.length - 1) {\n            clearValue();\n          } else {\n            clearActiveSection();\n          }\n          resetCharacterQuery();\n          break;\n        }\n\n      // Increment / decrement the selected section value\n      case ['ArrowUp', 'ArrowDown', 'Home', 'End', 'PageUp', 'PageDown'].includes(event.key):\n        {\n          event.preventDefault();\n          if (readOnly || selectedSectionIndexes == null) {\n            break;\n          }\n          const activeSection = state.sections[selectedSectionIndexes.startIndex];\n          const activeDateManager = fieldValueManager.getActiveDateManager(utils, state, activeSection);\n          const newSectionValue = adjustSectionValue(utils, activeSection, event.key, sectionsValueBoundaries, activeDateManager.activeDate);\n          updateSectionValue({\n            activeSection,\n            newSectionValue,\n            shouldGoToNextSection: false\n          });\n          break;\n        }\n    }\n  });\n  useEnhancedEffect(() => {\n    if (selectedSectionIndexes == null) {\n      return;\n    }\n    const firstSelectedSection = state.sections[selectedSectionIndexes.startIndex];\n    const lastSelectedSection = state.sections[selectedSectionIndexes.endIndex];\n    let selectionStart = firstSelectedSection.startInInput;\n    let selectionEnd = lastSelectedSection.endInInput;\n    if (selectedSectionIndexes.shouldSelectBoundarySelectors) {\n      selectionStart -= firstSelectedSection.startSeparator.length;\n      selectionEnd += lastSelectedSection.endSeparator.length;\n    }\n    if (selectionStart !== inputRef.current.selectionStart || selectionEnd !== inputRef.current.selectionEnd) {\n      inputRef.current.setSelectionRange(selectionStart, selectionEnd);\n    }\n  });\n  const validationError = useValidation(_extends({}, internalProps, {\n    value: state.value\n  }), validator, valueManager.isSameError, valueManager.defaultErrorState);\n  const inputError = React.useMemo(() => {\n    // only override when `error` is undefined.\n    // in case of multi input fields, the `error` value is provided externally and will always be defined.\n    if (error !== undefined) {\n      return error;\n    }\n    return fieldValueManager.hasError(validationError);\n  }, [fieldValueManager, validationError, error]);\n  React.useEffect(() => {\n    // Select the right section when focused on mount (`autoFocus = true` on the input)\n    if (inputRef.current && inputRef.current === document.activeElement) {\n      setSelectedSections('all');\n    }\n    return () => window.clearTimeout(focusTimeoutRef.current);\n  }, []); // eslint-disable-line react-hooks/exhaustive-deps\n\n  // If `state.tempValueStrAndroid` is still defined when running `useEffect`,\n  // Then `onChange` has only been called once, which means the user pressed `Backspace` to reset the section.\n  // This causes a small flickering on Android,\n  // But we can't use `useEnhancedEffect` which is always called before the second `onChange` call and then would cause false positives.\n  React.useEffect(() => {\n    if (state.tempValueStrAndroid != null && selectedSectionIndexes != null) {\n      resetCharacterQuery();\n      clearActiveSection();\n    }\n  }, [state.tempValueStrAndroid]); // eslint-disable-line react-hooks/exhaustive-deps\n\n  const valueStr = React.useMemo(() => {\n    var _state$tempValueStrAn;\n    return (_state$tempValueStrAn = state.tempValueStrAndroid) != null ? _state$tempValueStrAn : fieldValueManager.getValueStrFromSections(state.sections);\n  }, [state.sections, fieldValueManager, state.tempValueStrAndroid]);\n  const inputMode = React.useMemo(() => {\n    if (selectedSectionIndexes == null) {\n      return 'text';\n    }\n    if (state.sections[selectedSectionIndexes.startIndex].contentType === 'letter') {\n      return 'text';\n    }\n    return 'tel';\n  }, [selectedSectionIndexes, state.sections]);\n  const inputHasFocus = inputRef.current && inputRef.current === document.activeElement;\n  const shouldShowPlaceholder = !inputHasFocus && (!state.value || valueManager.areValuesEqual(utils, state.value, valueManager.emptyValue));\n  return _extends({\n    placeholder: state.placeholder,\n    autoComplete: 'off'\n  }, otherForwardedProps, {\n    value: shouldShowPlaceholder ? '' : valueStr,\n    inputMode,\n    readOnly,\n    onClick: handleInputClick,\n    onFocus: handleInputFocus,\n    onBlur: handleInputBlur,\n    onPaste: handleInputPaste,\n    onChange: handleInputChange,\n    onKeyDown: handleInputKeyDown,\n    onMouseUp: handleInputMouseUp,\n    error: inputError,\n    ref: handleRef\n  });\n};","map":{"version":3,"names":["_extends","_objectWithoutPropertiesLoose","_excluded","React","useEnhancedEffect","useEventCallback","useForkRef","useValidation","useUtils","adjustSectionValue","isAndroid","cleanString","useFieldState","useFieldCharacterEditing","useField","params","utils","formatTokenMap","Error","state","selectedSectionIndexes","setSelectedSections","clearValue","clearActiveSection","updateSectionValue","updateValueFromValueStr","setTempAndroidValueStr","sectionOrder","sectionsValueBoundaries","applyCharacterEditing","resetCharacterQuery","sections","inputRef","inputRefProp","internalProps","readOnly","forwardedProps","onClick","onKeyDown","onFocus","onBlur","onMouseUp","onPaste","error","fieldValueManager","valueManager","validator","otherForwardedProps","useRef","handleRef","focusTimeoutRef","undefined","syncSelectionFromDOM","_selectionStart","browserStartIndex","current","selectionStart","nextSectionIndex","startInInput","findIndex","section","startSeparator","length","sectionIndex","handleInputClick","arguments","handleInputMouseUp","event","preventDefault","handleInputFocus","input","clearTimeout","setTimeout","value","Number","selectionEnd","handleInputBlur","handleInputPaste","pastedValue","clipboardData","getData","startIndex","endIndex","activeSection","lettersOnly","test","digitsOnly","isValidPastedValue","contentType","handleInputChange","valueStr","target","cleanValueStr","prevValueStr","getValueStrFromSections","startOfDiffIndex","endOfDiffIndex","i","hasDiffOutsideOfActiveSection","start","end","activeSectionEndRelativeToNewValue","endSeparator","keyPressed","slice","handleInputKeyDown","key","ctrlKey","metaKey","neighbors","rightIndex","leftIndex","includes","activeDateManager","getActiveDateManager","newSectionValue","activeDate","shouldGoToNextSection","firstSelectedSection","lastSelectedSection","endInInput","shouldSelectBoundarySelectors","setSelectionRange","validationError","isSameError","defaultErrorState","inputError","useMemo","hasError","useEffect","document","activeElement","window","tempValueStrAndroid","_state$tempValueStrAn","inputMode","inputHasFocus","shouldShowPlaceholder","areValuesEqual","emptyValue","placeholder","autoComplete","onChange","ref"],"sources":["/Users/alissonrubas/Desktop/workout_site/cliente/node_modules/@mui/x-date-pickers/internals/hooks/useField/useField.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nconst _excluded = [\"onClick\", \"onKeyDown\", \"onFocus\", \"onBlur\", \"onMouseUp\", \"onPaste\", \"error\"];\nimport * as React from 'react';\nimport useEnhancedEffect from '@mui/utils/useEnhancedEffect';\nimport useEventCallback from '@mui/utils/useEventCallback';\nimport useForkRef from '@mui/utils/useForkRef';\nimport { useValidation } from '../validation/useValidation';\nimport { useUtils } from '../useUtils';\nimport { adjustSectionValue, isAndroid, cleanString } from './useField.utils';\nimport { useFieldState } from './useFieldState';\nimport { useFieldCharacterEditing } from './useFieldCharacterEditing';\nexport const useField = params => {\n  const utils = useUtils();\n  if (!utils.formatTokenMap) {\n    throw new Error('This adapter is not compatible with the field components');\n  }\n  const {\n    state,\n    selectedSectionIndexes,\n    setSelectedSections,\n    clearValue,\n    clearActiveSection,\n    updateSectionValue,\n    updateValueFromValueStr,\n    setTempAndroidValueStr,\n    sectionOrder,\n    sectionsValueBoundaries\n  } = useFieldState(params);\n  const {\n    applyCharacterEditing,\n    resetCharacterQuery\n  } = useFieldCharacterEditing({\n    sections: state.sections,\n    updateSectionValue,\n    sectionsValueBoundaries,\n    setTempAndroidValueStr\n  });\n  const {\n      inputRef: inputRefProp,\n      internalProps,\n      internalProps: {\n        readOnly = false\n      },\n      forwardedProps: {\n        onClick,\n        onKeyDown,\n        onFocus,\n        onBlur,\n        onMouseUp,\n        onPaste,\n        error\n      },\n      fieldValueManager,\n      valueManager,\n      validator\n    } = params,\n    otherForwardedProps = _objectWithoutPropertiesLoose(params.forwardedProps, _excluded);\n  const inputRef = React.useRef(null);\n  const handleRef = useForkRef(inputRefProp, inputRef);\n  const focusTimeoutRef = React.useRef(undefined);\n  const syncSelectionFromDOM = () => {\n    var _selectionStart;\n    const browserStartIndex = (_selectionStart = inputRef.current.selectionStart) != null ? _selectionStart : 0;\n    const nextSectionIndex = browserStartIndex <= state.sections[0].startInInput ? 1 // Special case if browser index is in invisible characters at the beginning.\n    : state.sections.findIndex(section => section.startInInput - section.startSeparator.length > browserStartIndex);\n    const sectionIndex = nextSectionIndex === -1 ? state.sections.length - 1 : nextSectionIndex - 1;\n    setSelectedSections(sectionIndex);\n  };\n  const handleInputClick = useEventCallback((...args) => {\n    onClick == null ? void 0 : onClick(...args);\n    syncSelectionFromDOM();\n  });\n  const handleInputMouseUp = useEventCallback(event => {\n    onMouseUp == null ? void 0 : onMouseUp(event);\n\n    // Without this, the browser will remove the selected when clicking inside an already-selected section.\n    event.preventDefault();\n  });\n  const handleInputFocus = useEventCallback((...args) => {\n    onFocus == null ? void 0 : onFocus(...args);\n    // The ref is guaranteed to be resolved at this point.\n    const input = inputRef.current;\n    clearTimeout(focusTimeoutRef.current);\n    focusTimeoutRef.current = setTimeout(() => {\n      // The ref changed, the component got remounted, the focus event is no longer relevant.\n      if (!input || input !== inputRef.current) {\n        return;\n      }\n      if (selectedSectionIndexes != null) {\n        return;\n      }\n      if (\n      // avoid selecting all sections when focusing empty field without value\n      input.value.length && Number(input.selectionEnd) - Number(input.selectionStart) === input.value.length) {\n        setSelectedSections('all');\n      } else {\n        syncSelectionFromDOM();\n      }\n    });\n  });\n  const handleInputBlur = useEventCallback((...args) => {\n    onBlur == null ? void 0 : onBlur(...args);\n    setSelectedSections(null);\n  });\n  const handleInputPaste = useEventCallback(event => {\n    onPaste == null ? void 0 : onPaste(event);\n    if (readOnly) {\n      event.preventDefault();\n      return;\n    }\n    const pastedValue = event.clipboardData.getData('text');\n    if (selectedSectionIndexes && selectedSectionIndexes.startIndex === selectedSectionIndexes.endIndex) {\n      const activeSection = state.sections[selectedSectionIndexes.startIndex];\n      const lettersOnly = /^[a-zA-Z]+$/.test(pastedValue);\n      const digitsOnly = /^[0-9]+$/.test(pastedValue);\n      const isValidPastedValue = activeSection.contentType === 'letter' && lettersOnly || activeSection.contentType === 'digit' && digitsOnly;\n      if (isValidPastedValue) {\n        // Early return to let the paste update section, value\n        return;\n      }\n      if (lettersOnly || digitsOnly) {\n        // The pasted value correspond to a single section but not the expected type\n        // skip the modification\n        event.preventDefault();\n        return;\n      }\n    }\n    event.preventDefault();\n    updateValueFromValueStr(pastedValue);\n  });\n  const handleInputChange = useEventCallback(event => {\n    if (readOnly) {\n      return;\n    }\n    const valueStr = event.target.value;\n    const cleanValueStr = cleanString(valueStr);\n\n    // If no section is selected, we just try to parse the new value\n    // This line is mostly triggered by imperative code / application tests.\n    if (selectedSectionIndexes == null) {\n      updateValueFromValueStr(cleanValueStr);\n      return;\n    }\n    const prevValueStr = cleanString(fieldValueManager.getValueStrFromSections(state.sections));\n    let startOfDiffIndex = -1;\n    let endOfDiffIndex = -1;\n    for (let i = 0; i < prevValueStr.length; i += 1) {\n      if (startOfDiffIndex === -1 && prevValueStr[i] !== cleanValueStr[i]) {\n        startOfDiffIndex = i;\n      }\n      if (endOfDiffIndex === -1 && prevValueStr[prevValueStr.length - i - 1] !== cleanValueStr[cleanValueStr.length - i - 1]) {\n        endOfDiffIndex = i;\n      }\n    }\n    const activeSection = state.sections[selectedSectionIndexes.startIndex];\n    const hasDiffOutsideOfActiveSection = startOfDiffIndex < activeSection.start || prevValueStr.length - endOfDiffIndex - 1 > activeSection.end;\n    if (hasDiffOutsideOfActiveSection) {\n      // TODO: Support if the new date is valid\n      return;\n    }\n\n    // The active section being selected, the browser has replaced its value with the key pressed by the user.\n    const activeSectionEndRelativeToNewValue = cleanValueStr.length - prevValueStr.length + activeSection.end - cleanString(activeSection.endSeparator || '').length;\n    const keyPressed = cleanValueStr.slice(activeSection.start, activeSectionEndRelativeToNewValue);\n    if (isAndroid() && keyPressed.length === 0) {\n      setTempAndroidValueStr(valueStr);\n      return;\n    }\n    applyCharacterEditing({\n      keyPressed,\n      sectionIndex: selectedSectionIndexes.startIndex\n    });\n  });\n  const handleInputKeyDown = useEventCallback(event => {\n    onKeyDown == null ? void 0 : onKeyDown(event);\n\n    // eslint-disable-next-line default-case\n    switch (true) {\n      // Select all\n      case event.key === 'a' && (event.ctrlKey || event.metaKey):\n        {\n          // prevent default to make sure that the next line \"select all\" while updating\n          // the internal state at the same time.\n          event.preventDefault();\n          setSelectedSections('all');\n          break;\n        }\n\n      // Move selection to next section\n      case event.key === 'ArrowRight':\n        {\n          event.preventDefault();\n          if (selectedSectionIndexes == null) {\n            setSelectedSections(sectionOrder.startIndex);\n          } else if (selectedSectionIndexes.startIndex !== selectedSectionIndexes.endIndex) {\n            setSelectedSections(selectedSectionIndexes.endIndex);\n          } else {\n            const nextSectionIndex = sectionOrder.neighbors[selectedSectionIndexes.startIndex].rightIndex;\n            if (nextSectionIndex !== null) {\n              setSelectedSections(nextSectionIndex);\n            }\n          }\n          break;\n        }\n\n      // Move selection to previous section\n      case event.key === 'ArrowLeft':\n        {\n          event.preventDefault();\n          if (selectedSectionIndexes == null) {\n            setSelectedSections(sectionOrder.endIndex);\n          } else if (selectedSectionIndexes.startIndex !== selectedSectionIndexes.endIndex) {\n            setSelectedSections(selectedSectionIndexes.startIndex);\n          } else {\n            const nextSectionIndex = sectionOrder.neighbors[selectedSectionIndexes.startIndex].leftIndex;\n            if (nextSectionIndex !== null) {\n              setSelectedSections(nextSectionIndex);\n            }\n          }\n          break;\n        }\n\n      // Reset the value of the selected section\n      case ['Backspace', 'Delete'].includes(event.key):\n        {\n          event.preventDefault();\n          if (readOnly) {\n            break;\n          }\n          if (selectedSectionIndexes == null || selectedSectionIndexes.startIndex === 0 && selectedSectionIndexes.endIndex === state.sections.length - 1) {\n            clearValue();\n          } else {\n            clearActiveSection();\n          }\n          resetCharacterQuery();\n          break;\n        }\n\n      // Increment / decrement the selected section value\n      case ['ArrowUp', 'ArrowDown', 'Home', 'End', 'PageUp', 'PageDown'].includes(event.key):\n        {\n          event.preventDefault();\n          if (readOnly || selectedSectionIndexes == null) {\n            break;\n          }\n          const activeSection = state.sections[selectedSectionIndexes.startIndex];\n          const activeDateManager = fieldValueManager.getActiveDateManager(utils, state, activeSection);\n          const newSectionValue = adjustSectionValue(utils, activeSection, event.key, sectionsValueBoundaries, activeDateManager.activeDate);\n          updateSectionValue({\n            activeSection,\n            newSectionValue,\n            shouldGoToNextSection: false\n          });\n          break;\n        }\n    }\n  });\n  useEnhancedEffect(() => {\n    if (selectedSectionIndexes == null) {\n      return;\n    }\n    const firstSelectedSection = state.sections[selectedSectionIndexes.startIndex];\n    const lastSelectedSection = state.sections[selectedSectionIndexes.endIndex];\n    let selectionStart = firstSelectedSection.startInInput;\n    let selectionEnd = lastSelectedSection.endInInput;\n    if (selectedSectionIndexes.shouldSelectBoundarySelectors) {\n      selectionStart -= firstSelectedSection.startSeparator.length;\n      selectionEnd += lastSelectedSection.endSeparator.length;\n    }\n    if (selectionStart !== inputRef.current.selectionStart || selectionEnd !== inputRef.current.selectionEnd) {\n      inputRef.current.setSelectionRange(selectionStart, selectionEnd);\n    }\n  });\n  const validationError = useValidation(_extends({}, internalProps, {\n    value: state.value\n  }), validator, valueManager.isSameError, valueManager.defaultErrorState);\n  const inputError = React.useMemo(() => {\n    // only override when `error` is undefined.\n    // in case of multi input fields, the `error` value is provided externally and will always be defined.\n    if (error !== undefined) {\n      return error;\n    }\n    return fieldValueManager.hasError(validationError);\n  }, [fieldValueManager, validationError, error]);\n  React.useEffect(() => {\n    // Select the right section when focused on mount (`autoFocus = true` on the input)\n    if (inputRef.current && inputRef.current === document.activeElement) {\n      setSelectedSections('all');\n    }\n    return () => window.clearTimeout(focusTimeoutRef.current);\n  }, []); // eslint-disable-line react-hooks/exhaustive-deps\n\n  // If `state.tempValueStrAndroid` is still defined when running `useEffect`,\n  // Then `onChange` has only been called once, which means the user pressed `Backspace` to reset the section.\n  // This causes a small flickering on Android,\n  // But we can't use `useEnhancedEffect` which is always called before the second `onChange` call and then would cause false positives.\n  React.useEffect(() => {\n    if (state.tempValueStrAndroid != null && selectedSectionIndexes != null) {\n      resetCharacterQuery();\n      clearActiveSection();\n    }\n  }, [state.tempValueStrAndroid]); // eslint-disable-line react-hooks/exhaustive-deps\n\n  const valueStr = React.useMemo(() => {\n    var _state$tempValueStrAn;\n    return (_state$tempValueStrAn = state.tempValueStrAndroid) != null ? _state$tempValueStrAn : fieldValueManager.getValueStrFromSections(state.sections);\n  }, [state.sections, fieldValueManager, state.tempValueStrAndroid]);\n  const inputMode = React.useMemo(() => {\n    if (selectedSectionIndexes == null) {\n      return 'text';\n    }\n    if (state.sections[selectedSectionIndexes.startIndex].contentType === 'letter') {\n      return 'text';\n    }\n    return 'tel';\n  }, [selectedSectionIndexes, state.sections]);\n  const inputHasFocus = inputRef.current && inputRef.current === document.activeElement;\n  const shouldShowPlaceholder = !inputHasFocus && (!state.value || valueManager.areValuesEqual(utils, state.value, valueManager.emptyValue));\n  return _extends({\n    placeholder: state.placeholder,\n    autoComplete: 'off'\n  }, otherForwardedProps, {\n    value: shouldShowPlaceholder ? '' : valueStr,\n    inputMode,\n    readOnly,\n    onClick: handleInputClick,\n    onFocus: handleInputFocus,\n    onBlur: handleInputBlur,\n    onPaste: handleInputPaste,\n    onChange: handleInputChange,\n    onKeyDown: handleInputKeyDown,\n    onMouseUp: handleInputMouseUp,\n    error: inputError,\n    ref: handleRef\n  });\n};"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}